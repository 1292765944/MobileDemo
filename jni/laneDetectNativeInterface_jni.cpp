/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include "laneDetectNativeInterface_jni.h"
#include "lane/LaneDetector.h"
#include "lane/Img2IPM.h"
#include <vector>
#include "file_util.h"

#include <android/log.h>

#include "util.h"

using namespace LaneDetector;
/* Header for class com_baidu_detector_jni_DetectionBasedTracker */

#ifndef _Included_com_baidu_detector_jni_DetectionBasedTracker
#define _Included_com_baidu_detector_jni_DetectionBasedTracker
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_baidu_detector_jni_LaneDetectNativeInterface
 * Method:    getLane
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_com_baidu_detector_jni_LaneDetectNativeInterface_nativeGetLane
  (JNIEnv *jenv, jclass obj, jlong pImgGrayMat, jobject clSplines, jobject clSplineScores, jobject clCubicPolies)
{
	char config_file_path[200];
	getExternalRootDir(jenv, obj, config_file_path);
	LOGD("Enter function: nativeGetLane");
	// 获取三种基本数据类型的设置方法
	jclass jSpline = jenv->FindClass("com/baidu/detector/jni/bean/Spline");
	jmethodID setDegree =  jenv->GetMethodID(jSpline, "setDegree", "(I)V");
	jmethodID setScore = jenv->GetMethodID(jSpline, "setScore", "(F)V");
	jmethodID setColor = jenv->GetMethodID(jSpline, "setColor", "(I)V");
	jmethodID splineConstructor = jenv->GetMethodID(jSpline, "<init>", "()V");

	jmethodID setPoints = jenv->GetMethodID(jSpline, "setPoints",
								"([Lcom/baidu/detector/jni/bean/CvPoint2D32f;)V");
	jclass point = jenv->FindClass("com/baidu/detector/jni/bean/CvPoint2D32f");
	jmethodID setX = jenv->GetMethodID(point, "setX", "(F)V");
	jmethodID setY = jenv->GetMethodID(point, "setY", "(F)V");
	jmethodID pointConstructor = jenv->GetMethodID(point, "<init>", "()V");

	// 参数 clSplines 和 clSplineScores 是两个容器，需要得到其 add 方法
	jclass splines = jenv->GetObjectClass(clSplines);
	jmethodID arrylistAddspl = jenv->GetMethodID(splines,"add","(Ljava/lang/Object;)Z");
	jclass scores = jenv->GetObjectClass(clSplineScores);
	jmethodID arrylistAddsco = jenv->GetMethodID(scores,"add","(Ljava/lang/Object;)Z");

	// 获得浮点型数据的构造方法
	jclass floatClass = jenv->FindClass("java/lang/Float");
	jmethodID floatConstructor = jenv->GetMethodID(floatClass, "<init>", "(F)V");

	LOGD("Before call native lib");
	// 调用本地函数检测车道线
	CvMat cvMat = *((Mat*)pImgGrayMat);
	vector<Spline> cpp_splines ;
	vector<float> spline_scores;
	LOGD("cols: %d", cvMat.cols);
		LOGD(" : ");
	LOGD("rows: %d", cvMat.rows);
	LOGD("type: %d", cvMat.type);
	mcvGetLanes_packing( &cvMat, &cpp_splines, &spline_scores, config_file_path);
	vector<CubicPoly> cpp_polys;
	myCvtSpine2Poly(cpp_splines, cpp_polys);

	LOGD("After call native lib");
	// 将检测结果返回到上层Java
	vector<Spline>::iterator iterator_spline;
	for(iterator_spline = cpp_splines.begin(); iterator_spline != cpp_splines.end(); iterator_spline++)
	{
		Spline spline= *iterator_spline;
		jobject javaSplineObj = jenv->NewObject(jSpline, splineConstructor);
		jenv->CallVoidMethod(javaSplineObj, setDegree, spline.degree);
		jenv->CallVoidMethod(javaSplineObj, setScore, spline.score);
		switch(spline.color){
		case LINE_COLOR_NONE:
			jenv->CallVoidMethod(javaSplineObj, setColor, 0);
			break;
		case LINE_COLOR_YELLOW:
			jenv->CallVoidMethod(javaSplineObj, setColor, 1);
			break;
		case LINE_COLOR_WHITE:
			jenv->CallVoidMethod(javaSplineObj, setColor, 2);
			break;
		}

		jobjectArray javaPoints = jenv->NewObjectArray(4, point, NULL);
		for(int i=0; i<4; i++) {
			jobject javaPoint = jenv->NewObject(point, pointConstructor);
			jenv->CallVoidMethod(javaPoint, setX, spline.points[i].x);
			jenv->CallVoidMethod(javaPoint, setY, spline.points[i].y);
			jenv->SetObjectArrayElement(javaPoints, i, javaPoint);
		}
		jenv->CallVoidMethod(javaSplineObj, setPoints, javaPoints);

		jenv->CallBooleanMethod(clSplines, arrylistAddspl, javaSplineObj);
	}

	vector<float>::iterator iterator_score;
	for(iterator_score=spline_scores.begin(); iterator_score!=spline_scores.end(); iterator_score++)
	{
		float cpp_score = *iterator_score;
		jobject javaScore = jenv->NewObject(floatClass, floatConstructor, cpp_score);
		jenv->CallBooleanMethod(clSplineScores, arrylistAddsco, javaScore);
	}

	// Java CubicPoly 相关设置
	jclass cubicPolyArrayList = jenv->GetObjectClass(clCubicPolies);
	jmethodID arrylistAddCubicPoly = jenv->GetMethodID(cubicPolyArrayList,"add","(Ljava/lang/Object;)Z");
	jclass javaCubicPolyClass = jenv->FindClass("com/baidu/detector/jni/bean/CubicPoly");
	jmethodID cubicPolyConstructor = jenv->GetMethodID(javaCubicPolyClass, "<init>", "()V");
	jmethodID setP0 = jenv->GetMethodID(javaCubicPolyClass, "setP0", "(F)V");
	jmethodID setP1 = jenv->GetMethodID(javaCubicPolyClass, "setP1", "(F)V");
	jmethodID setP2 = jenv->GetMethodID(javaCubicPolyClass, "setP2", "(F)V");
	jmethodID setP3 = jenv->GetMethodID(javaCubicPolyClass, "setP3", "(F)V");
	jmethodID setStartPoint = jenv->GetMethodID(javaCubicPolyClass, "setStartPoint", "(Lcom/baidu/detector/jni/bean/Point;)V");
	jmethodID setEndPoint = jenv->GetMethodID(javaCubicPolyClass, "setEndPoint", "(Lcom/baidu/detector/jni/bean/Point;)V");

	jclass javaPointClass = jenv->FindClass("com/baidu/detector/jni/bean/Point");
	jmethodID pointClassConstructor = jenv->GetMethodID(javaPointClass, "<init>", "()V");
	jmethodID setXPoint = jenv->GetMethodID(javaPointClass, "setX", "(I)V");
	jmethodID setYPoint = jenv->GetMethodID(javaPointClass, "setY", "(I)V");

	vector<CubicPoly>::iterator iterator_cubicPoly;
	for(iterator_cubicPoly = cpp_polys.begin(); iterator_cubicPoly != cpp_polys.end(); iterator_cubicPoly++)
	{
		CubicPoly cpp_cubicPoly = *iterator_cubicPoly;
		jobject javaCubicPoly = jenv->NewObject(javaCubicPolyClass, cubicPolyConstructor);
		// 根据本地cpp_cubicPoly设置Java_cubicPoly中的startPoint和endPoint的值
		jobject javaPointObjStart = jenv->NewObject(javaPointClass, pointClassConstructor);
		jobject javaPointObjEnd = jenv->NewObject(javaPointClass, pointClassConstructor);
		jenv->CallVoidMethod(javaPointObjStart, setXPoint, cpp_cubicPoly.startPoint.x);
		jenv->CallVoidMethod(javaPointObjStart, setYPoint, cpp_cubicPoly.startPoint.y);
		jenv->CallVoidMethod(javaPointObjEnd, setXPoint, cpp_cubicPoly.endPoint.x);
		jenv->CallVoidMethod(javaPointObjEnd, setYPoint, cpp_cubicPoly.endPoint.y);
		jenv->CallVoidMethod(javaCubicPoly, setStartPoint, javaPointObjStart);
		jenv->CallVoidMethod(javaCubicPoly, setEndPoint, javaPointObjEnd);
		// 根据本地cpp_cubicPoly设置Java_cubicPoly中的po-p3的值
		jenv->CallVoidMethod(javaCubicPoly, setP0, cpp_cubicPoly.po);
		jenv->CallVoidMethod(javaCubicPoly, setP1, cpp_cubicPoly.p1);
		jenv->CallVoidMethod(javaCubicPoly, setP2, cpp_cubicPoly.p2);
		jenv->CallVoidMethod(javaCubicPoly, setP3, cpp_cubicPoly.p3);
		// 添加到列表中，返回给上层Java使用
		jenv->CallBooleanMethod(clCubicPolies, arrylistAddCubicPoly, javaCubicPoly);
	}

	LOGD("Exit function");
}


JNIEXPORT void JNICALL Java_com_baidu_detector_jni_LaneDetectNativeInterface_nativeSaveAdjustedPoints
  (JNIEnv *jenv, jclass obj, jfloat x1, jfloat y1,
		  	  	  	  	  	  jfloat x2, jfloat y2,
		  	  	  	  	  	  jfloat x3, jfloat y3,
		  	  	  	  	  	  jfloat x4, jfloat y4,
		  	  	  	  	  	  jint cols, jint rows)
{
	Point clPoints[4];
	clPoints[0].x = (int) x1;
	clPoints[0].y = (int) y1;
	clPoints[1].x = (int) x2;
	clPoints[1].y = (int) y2;
	clPoints[2].x = (int) x3;
	clPoints[2].y = (int) y3;
	clPoints[3].x = (int) x4;
	clPoints[3].y = (int) y4;

	char configFileDir[200];
	getExternalRootDir(jenv, obj, configFileDir);
	strcat(configFileDir, "/lane/");
	string path(configFileDir);
	LOGD("Prepare to enter function Img2IPM::process, the config file dir is: %s", configFileDir);
	Img2IPM img2ipm;
	img2ipm.process(clPoints, path, cols, rows);
}

#ifdef __cplusplus
}
#endif
#endif

